"use strict";(self.webpackChunkakita_docs=self.webpackChunkakita_docs||[]).push([[2624],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return g}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,g=d["".concat(l,".").concat(m)]||d[m]||u[m]||i;return n?r.createElement(g,s(s({ref:t},p),{},{components:n})):r.createElement(g,s({ref:t},p))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:a,s[1]=o;for(var c=2;c<i;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2301:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return d}});var r=n(3117),a=n(102),i=(n(7294),n(3905)),s=["components"],o={title:"Ng Entity Service"},l=void 0,c={unversionedId:"angular/entity-service",id:"angular/entity-service",title:"Ng Entity Service",description:"There\u2019s even more boilerplate we can save you, by creating an Akita entity service, which follows the standard RESTful naming conventions by default.",source:"@site/docs/angular/entity-service.mdx",sourceDirName:"angular",slug:"/angular/entity-service",permalink:"/akita/docs/angular/entity-service",draft:!1,editUrl:"https://github.com/salesforce/akita/edit/master/docs/docs/angular/entity-service.mdx",tags:[],version:"current",frontMatter:{title:"Ng Entity Service"},sidebar:"docs",previous:{title:"Local Component State",permalink:"/akita/docs/angular/local-state"},next:{title:"Effects",permalink:"/akita/docs/angular/effects"}},p={},d=[{value:"Getting Started",id:"getting-started",level:2},{value:"Entity Service Loader",id:"entity-service-loader",level:2},{value:"Entity Service Notifier",id:"entity-service-notifier",level:2},{value:"Options",id:"options",level:2}],u={toc:d};function m(e){var t=e.components,n=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"There\u2019s even more boilerplate we can save you, by creating an Akita entity service, which follows the standard ",(0,i.kt)("a",{parentName:"p",href:"https://restfulapi.net/resource-naming/"},"RESTful naming conventions")," by default."),(0,i.kt)("p",null,"Specifically, this service can be extremely useful in systems that use strict url patterns, such as CMS, admin dashboards, etc."),(0,i.kt)("h2",{id:"getting-started"},"Getting Started"),(0,i.kt)("p",null,"After installing Akita, we simply run:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm install @datorama/akita-ng-entity-service\n")),(0,i.kt)("p",null,"Let\u2019s use ",(0,i.kt)("a",{parentName:"p",href:"https://jsonplaceholder.typicode.com/"},"JSONPlaceholder")," as our REST API and quickly scaffold a feature for Posts. To get started we run:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"ng g af posts\n")),(0,i.kt)("p",null,"This schematics command generates an Akita ",(0,i.kt)("inlineCode",{parentName:"p"},"PostsStore"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"PostsQuery"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"PostsService"),". First we need to define the base api url that will be used for each request. This is done when adding the service configuration to the module:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="app.module.ts"',title:'"app.module.ts"'},"import {\n  HttpMethod,\n  NG_ENTITY_SERVICE_CONFIG,\n  NgEntityServiceGlobalConfig\n} from '@datorama/akita-ng-entity-service';\n\n@NgModule({\n  ...\n  providers: [\n    {\n      provide: NG_ENTITY_SERVICE_CONFIG,\n      useValue: {\n        baseUrl: 'https://jsonplaceholder.typicode.com'\n      }\n    }\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n\n")),(0,i.kt)("p",null,"Note that if you have server calls that use a different base url than the one you defined in the above setting, you can modify the url per service, or use a factory if you dynamically generate the url based on other providers\u2019 data. Our service looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="posts.service.ts"',title:'"posts.service.ts"'},"import { Injectable } from '@angular/core';\nimport { NgEntityService } from '@datorama/akita-ng-entity-service';\nimport { PostsState, PostsStore } from './posts.store';\n\n@Injectable({ providedIn: 'root' })\nexport class PostsService extends NgEntityService<PostsState> {\n  constructor(protected store: PostsStore) {\n    super(store);\n  }\n}\n")),(0,i.kt)("p",null,"This ensures that the service will automatically perform its CRUD operations on the ",(0,i.kt)("inlineCode",{parentName:"p"},"PostsStore")," we\u2019ve generated. By extending ",(0,i.kt)("inlineCode",{parentName:"p"},"NgEntityService"),", we get a several built-in API calls without the need to add them ourselves: ",(0,i.kt)("inlineCode",{parentName:"p"},"get()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"add()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"update()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"delete()"),". Next, let\u2019s create a component that uses those calls:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="posts.component.ts"',title:'"posts.component.ts"'},"@Component()\nexport class PostsPageComponent {\n  posts$ = this.postsQuery.selectAll();\n\n  constructor(private postsQuery: PostsQuery, private postsService: PostsService) {}\n\n  ngOnInit() {\n    this.postsService.get().subscribe();\n  }\n\n  getOne(id) {\n    this.postsService.get(id).subscribe();\n  }\n\n  add() {\n    this.postsService.add({ title: 'New Post', body: '' }).subscribe();\n  }\n\n  update(id) {\n    this.postsService.update(id, { title: 'New title' }).subscribe({\n      error: (error) => {\n        this.error = error;\n      },\n    });\n  }\n\n  remove(id) {\n    this.postsService.delete(id).subscribe();\n  }\n}\n")),(0,i.kt)("p",null,"As you can see, since all the tasks of initalizing the requests and updating the store are all baked in to the entity service, all we need to do is call the relevant methods. Additionally, each method takes a config object where we can pass some or all of the following parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"{\n  params?: HttpParams;\n  headers?: HttpHeaders;\n  url?: string;\n  urlPostfix?: string;\n  mapResponseFn?: (res) => Entity | Entity[];\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"resourceName")," used in the urls is by default identical to the store name, but we can easily configure it. For instance, if we want our posts service to fetch its posts from the articles url we can set it in the service config:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="posts.service.ts"',title:'"posts.service.ts"'},"@NgEntityServiceConfig({\n  resourceName: 'articles',\n  baseUrl: 'customBaseUrl',\n})\n@Injectable({ providedIn: 'root' })\nexport class PostsService extends NgEntityService<PostsState> {\n  constructor(protected store: PostsStore) {\n    super(store);\n  }\n}\n")),(0,i.kt)("p",null,"Alternatively, we can pass the config as the second parameter in the ",(0,i.kt)("inlineCode",{parentName:"p"},"super()")," call in the service\u2019s constructor."),(0,i.kt)("h2",{id:"entity-service-loader"},"Entity Service Loader"),(0,i.kt)("p",null,"Loading indication is a very common scenario \u2014 we often need to display to the user an indication that the server call has been made, and our app is currently in the process of loading the resulting data."),(0,i.kt)("p",null,"Akita\u2019s Entity Service comes with a built-in solution for these cases; The ",(0,i.kt)("inlineCode",{parentName:"p"},"NgEntityServiceLoader")," can listen to any entity service\u2019s built-in method and give us an indication of its loading status:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="posts.component.ts"',title:'"posts.component.ts"'},"import { NgEntityServiceLoader } from '@datorama/akita-ng-entity-service';\n\n@Component()\nexport class PostsPageComponent {\n  posts$ = this.postsQuery.selectAll();\n  loaders = this.loader.loadersFor('posts');\n\n  constructor(private postsQuery: PostsQuery, private postsService: PostsService, private loader: NgEntityServiceLoader) {}\n\n  ngOnInit() {\n    this.postsService.get().subscribe();\n  }\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"loaders")," object now contains loading indicators for each of the ",(0,i.kt)("inlineCode",{parentName:"p"},"PostsService")," methods; Each one holding an ",(0,i.kt)("inlineCode",{parentName:"p"},"observable")," boolean value, indicating the method\u2019s loading status. Thanks to that we can create customized gui in the component\u2019s template, based on those indicators :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="posts.component.html"',title:'"posts.component.html"'},'<ng-template #idle>Idle</ng-template>\n\n<h5>Loaders</h5>\n\n<p>Get =>\n  <span *ngIf="(loaders.get$ | async); else idle">Loading...</span>\n</p>\n\n<p>POST =>\n  <span *ngIf="(loaders.add$ | async); else idle">Loading...</span>\n</p>\n\n<p>PUT => <\n  span *ngIf="(loaders.update$ | async); else idle">Loading...</span>\n</p>\n\n<p>DELETE =>\n  <span *ngIf="(loaders.delete$ | async); else idle">Loading...</span>\n </p>\n')),(0,i.kt)("p",null,"We can also get indicators for a specific entity being updated or deleted by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"loaders.updateEntity(id)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"loaders.deleteEntity(id)"),", respectively."),(0,i.kt)("h2",{id:"entity-service-notifier"},"Entity Service Notifier"),(0,i.kt)("p",null,"In addition to that there are cases when we need to know whether certain operation has succeded or failed. For example, a global component that displays toast notifications to the user."),(0,i.kt)("p",null,"For this purpose the Entity Service package provides the ",(0,i.kt)("inlineCode",{parentName:"p"},"NgEntityServiceNotifier")," service, which we can subscribe to and get the status of any HTTP call that was made:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="notification.service.ts"',title:'"notification.service.ts"'},"import { NgEntityServiceNotifier } from '@datorama/akita-ng-entity-service';\n\nclass NotificationService {\n  constructor(private notifier: NgEntityServiceNotifier) {}\n\n  listen() {\n    this.notifier.action$.subscribe((action) => {\n      // show toast\n    });\n  }\n}\n")),(0,i.kt)("p",null,"The resulting data looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"{\n  storeName: string;\n  type: ActionType; // success/error\n  payload: any; // response from the server\n  method: HttpMethod;\n  successMsg?: string;\n  errorMsg?: string;\n}\n")),(0,i.kt)("p",null,"The package also exposes built-in operators, which allow us to filter the ",(0,i.kt)("inlineCode",{parentName:"p"},"type"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"store"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"HTTP")," method. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { NgEntityServiceNotifier, filterMethod, ofType, filterStore } from '@datorama/akita-ng-entity-service';\n\nthis.notifier.action$.pipe(filterStore('posts'), ofType('success'), filterMethod('DELETE'));\n")),(0,i.kt)("h2",{id:"options"},"Options"),(0,i.kt)("p",null,"The global ",(0,i.kt)("inlineCode",{parentName:"p"},"config")," provide takes the following object:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"{\n  provide: NG_ENTITY_SERVICE_CONFIG,\n  useValue: {\n    return {\n      baseUrl: 'https://jsonplaceholder.typicode.com',\n      httpMethods: {\n        PUT: HttpMethod.PATCH\n      },\n    } as NgEntityServiceGlobalConfig;\n  }\n}\n")))}m.isMDXComponent=!0}}]);