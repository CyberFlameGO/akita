"use strict";(self.webpackChunkakita_docs=self.webpackChunkakita_docs||[]).push([[8755],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return y}});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=i.createContext({}),s=function(e){var t=i.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=s(e.components);return i.createElement(d.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,d=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=s(n),h=o,y=p["".concat(d,".").concat(h)]||p[h]||c[h]||a;return n?i.createElement(y,r(r({ref:t},u),{},{components:n})):i.createElement(y,r({ref:t},u))}));function y(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=h;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l[p]="string"==typeof e?e:o,r[1]=l;for(var s=2;s<a;s++)r[s]=n[s];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},636:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return d},default:function(){return h},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return p}});var i=n(3117),o=n(102),a=(n(7294),n(3905)),r=["components"],l={title:"State History"},d=void 0,s={unversionedId:"plugins/state-history",id:"plugins/state-history",title:"State History",description:"The StateHistoryPlugin provides a convenient way for undo and redo functionality, saving you the trouble of maintaining a history in the app yourself.",source:"@site/docs/plugins/state-history.mdx",sourceDirName:"plugins",slug:"/plugins/state-history",permalink:"/akita/docs/plugins/state-history",draft:!1,editUrl:"https://github.com/salesforce/akita/edit/master/docs/docs/plugins/state-history.mdx",tags:[],version:"current",frontMatter:{title:"State History"},sidebar:"docs",previous:{title:"Class Support",permalink:"/akita/docs/additional/class"},next:{title:"Dirty Check",permalink:"/akita/docs/plugins/dirty-check"}},u={},p=[{value:"API",id:"api",level:2},{value:"<code>undo()</code>",id:"undo",level:3},{value:"<code>redo()</code>",id:"redo",level:3},{value:"<code>jump()</code>",id:"jump",level:3},{value:"<code>jumpToPast(index: number)</code>",id:"jumptopastindex-number",level:3},{value:"<code>jumpToFuture(index: number)</code>",id:"jumptofutureindex-number",level:3},{value:"<code>clear()</code>",id:"clear",level:3},{value:"<code>ignoreNext()</code>",id:"ignorenext",level:3},{value:"<code>destroy(clearHistory = false)</code>",id:"destroyclearhistory--false",level:3},{value:"<code>hasPast()</code>",id:"haspast",level:3},{value:"<code>hasFuture()</code>",id:"hasfuture",level:3},{value:"<code>hasPast$</code>",id:"haspast-1",level:3},{value:"<code>hasFuture$</code>",id:"hasfuture-1",level:3},{value:"Options",id:"options",level:2},{value:"<code>maxAge</code>",id:"maxage",level:3},{value:"<code>watchProperty</code>",id:"watchproperty",level:3},{value:"EntityStateHistoryPlugin",id:"entitystatehistoryplugin",level:2},{value:"API",id:"api-1",level:3},{value:"<code>undo(entityId?: IDS)</code>",id:"undoentityid-ids",level:3},{value:"<code>redo(entityId?: IDS)</code>",id:"redoentityid-ids",level:3},{value:"<code>jumpToPast(entityId?: IDS, index: number)</code>",id:"jumptopastentityid-ids-index-number",level:3},{value:"<code>jumpToFuture(entityId?: IDS, index: number)</code>",id:"jumptofutureentityid-ids-index-number",level:3},{value:"<code>clear(entityId?: IDS)</code>",id:"clearentityid-ids",level:3},{value:"<code>destroy(entityId?: IDS, clearHistory = false)</code>",id:"destroyentityid-ids-clearhistory--false",level:3},{value:"<code>hasPast(entityId: ID)</code>",id:"haspastentityid-id",level:3},{value:"<code>hasFuture(entityId: ID)</code>",id:"hasfutureentityid-id",level:3},{value:"Options",id:"options-1",level:2},{value:"<code>maxAge</code>",id:"maxage-1",level:3},{value:"<code>entityIds</code>",id:"entityids",level:3}],c={toc:p};function h(e){var t=e.components,n=(0,o.Z)(e,r);return(0,a.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"StateHistoryPlugin")," provides a convenient way for ",(0,a.kt)("inlineCode",{parentName:"p"},"undo")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"redo")," functionality, saving you the trouble of maintaining a history in the app yourself.\nTo use it you should instantiate a new ",(0,a.kt)("inlineCode",{parentName:"p"},"StateHistoryPlugin")," object, passing the ",(0,a.kt)("inlineCode",{parentName:"p"},"Query"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todos.component.ts"',title:'"todos.component.ts"'},"import { StateHistoryPlugin } from '@datorama/akita';\n\nexport class TodosPageComponent {\n  private stateHistory: StateHistoryPlugin;\n\n  constructor(private todosQuery: TodosQuery) {}\n\n  ngOnInit() {\n    this.stateHistory = new StateHistoryPlugin(this.todosQuery);\n  }\n}\n")),(0,a.kt)("p",null,"From the moment you call it, Akita's ",(0,a.kt)("inlineCode",{parentName:"p"},"StateHistory")," tracks the history of the store and gives you the following functionality:"),(0,a.kt)("h2",{id:"api"},"API"),(0,a.kt)("h3",{id:"undo"},(0,a.kt)("inlineCode",{parentName:"h3"},"undo()")),(0,a.kt)("p",null,"undo the last change."),(0,a.kt)("h3",{id:"redo"},(0,a.kt)("inlineCode",{parentName:"h3"},"redo()")),(0,a.kt)("p",null,"redo the last change."),(0,a.kt)("h3",{id:"jump"},(0,a.kt)("inlineCode",{parentName:"h3"},"jump()")),(0,a.kt)("p",null,"jump n steps in the past or forward."),(0,a.kt)("h3",{id:"jumptopastindex-number"},(0,a.kt)("inlineCode",{parentName:"h3"},"jumpToPast(index: number)")),(0,a.kt)("p",null,"jump to the provided index in the past (assuming index is valid)."),(0,a.kt)("h3",{id:"jumptofutureindex-number"},(0,a.kt)("inlineCode",{parentName:"h3"},"jumpToFuture(index: number)")),(0,a.kt)("p",null,"jump to the provided index in the future (assuming index is valid)."),(0,a.kt)("h3",{id:"clear"},(0,a.kt)("inlineCode",{parentName:"h3"},"clear()")),(0,a.kt)("p",null,"clear the history. "),(0,a.kt)("h3",{id:"ignorenext"},(0,a.kt)("inlineCode",{parentName:"h3"},"ignoreNext()")),(0,a.kt)("p",null,"ignores the next store's update call. You should call it before updating the store. "),(0,a.kt)("h3",{id:"destroyclearhistory--false"},(0,a.kt)("inlineCode",{parentName:"h3"},"destroy(clearHistory = false)")),(0,a.kt)("p",null,"unsubscribe and optionally clear the history."),(0,a.kt)("h3",{id:"haspast"},(0,a.kt)("inlineCode",{parentName:"h3"},"hasPast()")),(0,a.kt)("p",null,"A boolean flag that returns whether the history is not empty."),(0,a.kt)("h3",{id:"hasfuture"},(0,a.kt)("inlineCode",{parentName:"h3"},"hasFuture()")),(0,a.kt)("p",null,"A boolean flag that returns whether you're not in the latest step in the history."),(0,a.kt)("h3",{id:"haspast-1"},(0,a.kt)("inlineCode",{parentName:"h3"},"hasPast$")),(0,a.kt)("p",null,"An observable that returns whether the history is not empty."),(0,a.kt)("h3",{id:"hasfuture-1"},(0,a.kt)("inlineCode",{parentName:"h3"},"hasFuture$")),(0,a.kt)("p",null,"An observable that returns whether you're not in the latest step in the history."),(0,a.kt)("h2",{id:"options"},"Options"),(0,a.kt)("h3",{id:"maxage"},(0,a.kt)("inlineCode",{parentName:"h3"},"maxAge")),(0,a.kt)("p",null,"Maximum amount of changes to be stored in the history (default: 10):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const options = { maxAge: 3 };\nstateHistory = new StateHistoryPlugin(todosQuery, options);\n")),(0,a.kt)("h3",{id:"watchproperty"},(0,a.kt)("inlineCode",{parentName:"h3"},"watchProperty")),(0,a.kt)("p",null,"Watch a specific property:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const options = { watchProperty: 'editorText' };\nstateHistory = new StateHistoryPlugin(editorQuery, options);\n")),(0,a.kt)("h2",{id:"entitystatehistoryplugin"},"EntityStateHistoryPlugin"),(0,a.kt)("p",null,"In addition to the general history functionality,  Akita also provides a powerful API to help keep track of one or many entities, instead of the entire store. "),(0,a.kt)("p",null,"A good example is when you have a table or a list of entities that the users can modify, and you want to give them a way to undo/redo their changes per entity. Here is how you can do it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { EntityStateHistoryPlugin } from '@datorama/akita';\n\nexport class TodosPageComponent {\n  private collection: EntityStateHistoryPlugin;\n\n  constructor(private todosQuery: TodosQuery) {}\n\n  ngOnInit() {\n    this.collection = new EntityStateHistoryPlugin(this.todosQuery);\n  }\n}\n")),(0,a.kt)("p",null,"With this setup you will get the following functionality:"),(0,a.kt)("h3",{id:"api-1"},"API"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"type IDS = ID | ID[]"),";"),(0,a.kt)("h3",{id:"undoentityid-ids"},(0,a.kt)("inlineCode",{parentName:"h3"},"undo(entityId?: IDS)")),(0,a.kt)("p",null,"undo the last change."),(0,a.kt)("h3",{id:"redoentityid-ids"},(0,a.kt)("inlineCode",{parentName:"h3"},"redo(entityId?: IDS)")),(0,a.kt)("p",null,"redo the last change."),(0,a.kt)("h3",{id:"jumptopastentityid-ids-index-number"},(0,a.kt)("inlineCode",{parentName:"h3"},"jumpToPast(entityId?: IDS, index: number)")),(0,a.kt)("p",null,"jump to the provided index in the past (assuming index is valid)."),(0,a.kt)("h3",{id:"jumptofutureentityid-ids-index-number"},(0,a.kt)("inlineCode",{parentName:"h3"},"jumpToFuture(entityId?: IDS, index: number)")),(0,a.kt)("p",null,"jump to the provided index in the future (assuming index is valid)."),(0,a.kt)("h3",{id:"clearentityid-ids"},(0,a.kt)("inlineCode",{parentName:"h3"},"clear(entityId?: IDS)")),(0,a.kt)("p",null,"clear the history. "),(0,a.kt)("h3",{id:"destroyentityid-ids-clearhistory--false"},(0,a.kt)("inlineCode",{parentName:"h3"},"destroy(entityId?: IDS, clearHistory = false)")),(0,a.kt)("p",null,"unsubscribe and optionally clear the history. "),(0,a.kt)("h3",{id:"haspastentityid-id"},(0,a.kt)("inlineCode",{parentName:"h3"},"hasPast(entityId: ID)")),(0,a.kt)("p",null,"A boolean flag that returns whether the history is not empty."),(0,a.kt)("h3",{id:"hasfutureentityid-id"},(0,a.kt)("inlineCode",{parentName:"h3"},"hasFuture(entityId: ID)")),(0,a.kt)("p",null,"A boolean flag that returns whether you're not in the latest step in the history."),(0,a.kt)("h2",{id:"options-1"},"Options"),(0,a.kt)("h3",{id:"maxage-1"},(0,a.kt)("inlineCode",{parentName:"h3"},"maxAge")),(0,a.kt)("p",null,"Maximum amount of changes to be stored in the history (default: 10):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const options = { maxAge: 3 };\nstateHistory = new StateHistoryEntityPlugin(todosQuery, options);\n")),(0,a.kt)("h3",{id:"entityids"},(0,a.kt)("inlineCode",{parentName:"h3"},"entityIds")),(0,a.kt)("p",null,"A single id or an array of entity ids (default: all)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const options = { entityIds: [1, 2] };\nstateHistory = new StateHistoryEntityPlugin(editorQuery, options);\n")),(0,a.kt)("p",null,"Here's a complete example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="todos.component.html"',title:'"todos.component.html"'},'<table>\n  <tbody>\n    <tr *ngFor="let todo of todos$ | async">\n      <td>{{todo.title}}</td>\n      <td>\n        <input type="checkbox" [checked]="todo.completed" \n        (change)="update($event, todo)"/>\n      </td>\n      <td>\n        <i \n        [class.disabled]="!stateHistoryEntity.hasPast(todo.id)"\n        (click)="stateHistoryEntity.undo(todo.id)">undo</i>\n      </td>\n      <td>\n        <i \n        [class.disabled]="!stateHistoryEntity.hasFuture(todo.id)"\n        (click)="stateHistoryEntity.redo(todo.id)">redo</i>\n      </td>\n    </tr>\n  </tbody>\n</table>\n')))}h.isMDXComponent=!0}}]);