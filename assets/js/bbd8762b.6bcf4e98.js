"use strict";(self.webpackChunkakita_docs=self.webpackChunkakita_docs||[]).push([[7371],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return g}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),c=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=c(e.components);return r.createElement(p.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,g=u["".concat(p,".").concat(m)]||u[m]||d[m]||a;return n?r.createElement(g,s(s({ref:t},l),{},{components:n})):r.createElement(g,s({ref:t},l))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[u]="string"==typeof e?e:o,s[1]=i;for(var c=2;c<a;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7833:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return p},default:function(){return m},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return u}});var r=n(3117),o=n(102),a=(n(7294),n(3905)),s=["components"],i={title:"Architecture"},p=void 0,c={unversionedId:"angular/architecture",id:"angular/architecture",title:"Architecture",description:"Let's say we are building from scratch an e-commerce application. We start by creating a new project with Angular CLI:",source:"@site/docs/angular/architecture.mdx",sourceDirName:"angular",slug:"/angular/architecture",permalink:"/akita/docs/angular/architecture",draft:!1,editUrl:"https://github.com/salesforce/akita/edit/master/docs/docs/angular/architecture.mdx",tags:[],version:"current",frontMatter:{title:"Architecture"},sidebar:"docs",previous:{title:"Akita CLI",permalink:"/akita/docs/enhancers/cli"},next:{title:"Local Component State",permalink:"/akita/docs/angular/local-state"}},l={},u=[{value:"Session Feature",id:"session-feature",level:2},{value:"Products Feature",id:"products-feature",level:2},{value:"Join Queries",id:"join-queries",level:2}],d={toc:u};function m(e){var t=e.components,n=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Let's say we are building from scratch an e-commerce application. We start by creating a new project with Angular CLI:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npx @angular/cli new e-commerce\n")),(0,a.kt)("p",null,"Next, we'll add Akita by using schematics:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"ng add @datorama/akita\n")),(0,a.kt)("h2",{id:"session-feature"},"Session Feature"),(0,a.kt)("p",null,"Now, we want to add a session module to our application, so we'll create a ",(0,a.kt)("inlineCode",{parentName:"p"},"SessionModule"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"ng g m session\n")),(0,a.kt)("p",null,"Inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"session")," module we can create components such as ",(0,a.kt)("inlineCode",{parentName:"p"},"LoginComponent")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"SignupComponent"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"ng g c session/login\nng g c session/signup\n")),(0,a.kt)("p",null,"Now, it's time to choose our Store. The rule is simple. If you don't need to manage a collection of entities, you should go with the basic store. In this case, we only have one user, so we need to create the basic store:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"ng g af session/session --plain\n")),(0,a.kt)("p",null,"The above command creates a ",(0,a.kt)("inlineCode",{parentName:"p"},"SessionStore"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"SessionQuery"),", and a ",(0,a.kt)("inlineCode",{parentName:"p"},"SessionService"),". So now our application tree is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"\ud83d\udce6app\n \u2523 \ud83d\udcc2session\n \u2503 \u2523 \ud83d\udcc2login\n \u2503 \u2503 \u2523 \ud83d\udcdclogin.component.css\n \u2503 \u2503 \u2523 \ud83d\udcdclogin.component.html\n \u2503 \u2503 \u2523 \ud83d\udcdclogin.component.spec.ts\n \u2503 \u2503 \u2517 \ud83d\udcdclogin.component.ts\n \u2503 \u2523 \ud83d\udcc2state\n \u2503 \u2503 \u2523 \ud83d\udcdcsession.query.ts\n \u2503 \u2503 \u2523 \ud83d\udcdcsession.service.ts\n \u2503 \u2503 \u2517 \ud83d\udcdcsession.store.ts\n \u2503 \u2517 \ud83d\udcdcsession.module.ts\n \u2523 \ud83d\udcdcapp-routing.module.ts\n \u2523 \ud83d\udcdcapp.component.css\n \u2523 \ud83d\udcdcapp.component.html\n \u2523 \ud83d\udcdcapp.component.spec.ts\n \u2523 \ud83d\udcdcapp.component.ts\n \u2517 \ud83d\udcdcapp.module.ts\n")),(0,a.kt)("p",null,"Let's see each one of the files inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"state")," folder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="session.store.ts"',title:'"session.store.ts"'},"import { Injectable } from '@angular/core';\nimport { Store, StoreConfig } from '@datorama/akita';\n\nexport interface SessionState {\n  key: string;\n}\n\nexport function createInitialState(): SessionState {\n  return {\n    key: '',\n  };\n}\n\n@Injectable({ providedIn: 'root' })\n@StoreConfig({ name: 'session' })\nexport class SessionStore extends Store<SessionState> {\n  constructor() {\n    super(createInitialState());\n  }\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="session.query.ts"',title:'"session.query.ts"'},"import { Injectable } from '@angular/core';\nimport { Query } from '@datorama/akita';\nimport { SessionStore, SessionState } from './session.store';\n\n@Injectable({ providedIn: 'root' })\nexport class SessionQuery extends Query<SessionState> {\n  constructor(protected store: SessionStore) {\n    super(store);\n  }\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="session.service.ts"',title:'"session.service.ts"'},"import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { SessionStore } from './session.store';\n\n@Injectable({ providedIn: 'root' })\nexport class SessionService {\n  constructor(private sessionStore: SessionStore, private http: HttpClient) {}\n}\n")),(0,a.kt)("p",null,"Each one of the providers is marked as ",(0,a.kt)("inlineCode",{parentName:"p"},"@Injectable({ providedIn: 'root' })")," . It means that the store, the query, and the service are ",(0,a.kt)("strong",{parentName:"p"},"app-wide")," singletons, and therefore can be accessed everywhere in our application. For example, in components, directives, services, and queries."),(0,a.kt)("p",null,"Let's modify our ",(0,a.kt)("inlineCode",{parentName:"p"},"session.store")," file and add the relevant properties:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="session.store.ts"',title:'"session.store.ts"'},"import { Injectable } from '@angular/core';\nimport { Store, StoreConfig } from '@datorama/akita';\n\nexport interface SessionState {\n  name: string | null;\n  token: string | null;\n}\n\nexport function createInitialState(): SessionState {\n  return {\n    name: null,\n    token: null,\n  };\n}\n\n@Injectable({ providedIn: 'root' })\n@StoreConfig({ name: 'session' })\nexport class SessionStore extends Store<SessionState> {\n  constructor() {\n    super(createInitialState());\n  }\n}\n")),(0,a.kt)("p",null,"We recommend placing the logic for underlying queries inside the query class so it can be more readable and reusable:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="session.query.ts"',title:'"session.query.ts"'},"import { Injectable } from '@angular/core';\nimport { Query } from '@datorama/akita';\nimport { SessionStore, SessionState } from './session.store';\n\n@Injectable({ providedIn: 'root' })\nexport class SessionQuery extends Query<SessionState> {\n  selectIsLogin$ = this.select('token');\n  selectName$ = this.select('name');\n\n  constructor(protected store: SessionStore) {\n    super(store);\n  }\n}\n")),(0,a.kt)("p",null,"In the ",(0,a.kt)("inlineCode",{parentName:"p"},"service"),", we'll make our server calls, and update the store:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="session.service.ts"',title:'"session.service.ts"'},"import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { SessionStore } from './session.store';\nimport { tap } from 'rxjs';\n\n@Injectable({ providedIn: 'root' })\nexport class SessionService {\n  constructor(private sessionStore: SessionStore, private http: HttpClient) {}\n\n  login(creds) {\n    return this.http(endpoint).pipe(tap((user) => this.sessionStore.update(user)));\n  }\n}\n")),(0,a.kt)("h2",{id:"products-feature"},"Products Feature"),(0,a.kt)("p",null,"First, we need to create the ",(0,a.kt)("inlineCode",{parentName:"p"},"ProductsModule")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"ProductsPageComponent"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"ng g m products\nng g c products/products-page\n")),(0,a.kt)("p",null,"Next, we want to maintain a ",(0,a.kt)("strong",{parentName:"p"},"collection")," of products so we need to create an ",(0,a.kt)("inlineCode",{parentName:"p"},"EntityStore"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"ng g af products/products\n")),(0,a.kt)("p",null,"The above command creates a ",(0,a.kt)("inlineCode",{parentName:"p"},"ProductsStore"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ProductsQuery"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Product"),", and a ",(0,a.kt)("inlineCode",{parentName:"p"},"ProductsService"),". So now our application tree is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"\ud83d\udce6app\n \u2523 \ud83d\udcc2products\n \u2503 \u2523 \ud83d\udcc2products-page\n \u2503 \u2503 \u2523 \ud83d\udcdcproducts-page.component.css\n \u2503 \u2503 \u2523 \ud83d\udcdcproducts-page.component.html\n \u2503 \u2503 \u2523 \ud83d\udcdcproducts-page.component.spec.ts\n \u2503 \u2503 \u2517 \ud83d\udcdcproducts-page.component.ts\n \u2503 \u2523 \ud83d\udcc2state\n \u2503 \u2503 \u2523 \ud83d\udcdcproduct.model.ts\n \u2503 \u2503 \u2523 \ud83d\udcdcproducts.query.ts\n \u2503 \u2503 \u2523 \ud83d\udcdcproducts.service.ts\n \u2503 \u2503 \u2517 \ud83d\udcdcproducts.store.ts\n \u2503 \u2517 \ud83d\udcdcproducts.module.ts\n \u2523 \ud83d\udcc2session\n \u2503 \u2523 \ud83d\udcc2login\n \u2503 \u2503 \u2523 \ud83d\udcdclogin.component.css\n \u2503 \u2503 \u2523 \ud83d\udcdclogin.component.html\n \u2503 \u2503 \u2523 \ud83d\udcdclogin.component.spec.ts\n \u2503 \u2503 \u2517 \ud83d\udcdclogin.component.ts\n \u2503 \u2523 \ud83d\udcc2state\n \u2503 \u2503 \u2523 \ud83d\udcdcsession.query.ts\n \u2503 \u2503 \u2523 \ud83d\udcdcsession.service.ts\n \u2503 \u2503 \u2517 \ud83d\udcdcsession.store.ts\n \u2503 \u2517 \ud83d\udcdcsession.module.ts\n \u2523 \ud83d\udcdcapp-routing.module.ts\n \u2523 \ud83d\udcdcapp.component.css\n \u2523 \ud83d\udcdcapp.component.html\n \u2523 \ud83d\udcdcapp.component.spec.ts\n \u2523 \ud83d\udcdcapp.component.ts\n \u2517 \ud83d\udcdcapp.module.ts\n")),(0,a.kt)("p",null,"Let's see each one of the files inside the state folder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="products.store.ts"',title:'"products.store.ts"'},"import { Injectable } from '@angular/core';\nimport { Product } from './product.model';\nimport { EntityState, EntityStore, StoreConfig } from '@datorama/akita';\n\nexport interface ProductsState extends EntityState<Product, number> {}\n\n@Injectable({ providedIn: 'root' })\n@StoreConfig({ name: 'products' })\nexport class ProductsStore extends EntityStore<ProductsState> {\n  constructor() {\n    super();\n  }\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="products.model.ts"',title:'"products.model.ts"'},"export interface Product {\n  id: number;\n}\n\nexport function createProduct(params: Partial<Product>) {\n  return {} as Product;\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="products.query.ts"',title:'"products.query.ts"'},"import { Injectable } from '@angular/core';\nimport { QueryEntity } from '@datorama/akita';\nimport { ProductsStore, ProductsState } from './products.store';\n\n@Injectable({ providedIn: 'root' })\nexport class ProductsQuery extends QueryEntity<ProductsState> {\n  constructor(protected store: ProductsStore) {\n    super(store);\n  }\n}\nimport { ID } from '@datorama/akita';\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="products.service.ts"',title:'"products.service.ts"'},"import { Injectable } from '@angular/core';\nimport { ID } from '@datorama/akita';\nimport { HttpClient } from '@angular/common/http';\nimport { tap } from 'rxjs';\nimport { Product } from './product.model';\nimport { ProductsStore } from './products.store';\n\n@Injectable({ providedIn: 'root' })\nexport class ProductsService {\n  constructor(private productsStore: ProductsStore, private http: HttpClient) {}\n\n  get() {\n    return this.http.get<Product[]>('https://api.com').pipe(tap((entities) => this.productsStore.set(entities)));\n  }\n\n  add(product: Product) {\n    this.productsStore.add(product);\n  }\n\n  update(id, product: Partial<Product>) {\n    this.productsStore.update(id, product);\n  }\n\n  remove(id: ID) {\n    this.productsStore.remove(id);\n  }\n}\n")),(0,a.kt)("p",null,"You should follow the same principles as with the ",(0,a.kt)("inlineCode",{parentName:"p"},"Session")," feature."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Angular providers don't have to be wide app singletons, for more information read ",(0,a.kt)("a",{parentName:"p",href:"https://netbasal.com/angular-services-do-not-have-to-be-singletons-ffa879e62082"},"this")," article.")),(0,a.kt)("h2",{id:"join-queries"},"Join Queries"),(0,a.kt)("p",null,"Queries can talk to other queries, join entities from different stores, etc. Let's say we have a ",(0,a.kt)("inlineCode",{parentName:"p"},"products")," store and a ",(0,a.kt)("inlineCode",{parentName:"p"},"cart")," store:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="products.store.ts"',title:'"products.store.ts"'},"import { EntityState, EntityStore } from '@datorama/akita';\nimport { Product } from './products.model';\n\nexport interface ProductsState extends EntityState<Product, number> {}\n\n@Injectable({ providedIn: 'root' })\n@StoreConfig({ name: 'products' })\nexport class ProductsStore extends EntityStore<ProductsState> {\n  constructor() {\n    super();\n  }\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="product.model.ts"',title:'"product.model.ts"'},"export type Product = {\n  id: number;\n  title: string;\n  description: string;\n  price: number;\n};\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="cart.store.ts"',title:'"cart.store.ts"'},"export interface CartState extends EntityState<CartItem, number> {}\n\n@Injectable({ providedIn: 'root' })\n@StoreConfig({\n  name: 'cart',\n  idKey: 'productId',\n})\nexport class CartStore extends EntityStore<CartState> {\n  constructor() {\n    super();\n  }\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="cart-item.model.ts"',title:'"cart-item.model.ts"'},"export type CartItem = {\n  productId: Product['id'];\n  quantity: number;\n  total: number;\n};\n")),(0,a.kt)("p",null,"We need to show the list of cart items and the total amount, but we also need some information from the ",(0,a.kt)("inlineCode",{parentName:"p"},"product"),", like the ",(0,a.kt)("inlineCode",{parentName:"p"},"title")," and the ",(0,a.kt)("inlineCode",{parentName:"p"},"price"),". Therefore we need to join the ",(0,a.kt)("inlineCode",{parentName:"p"},"CartStore")," with the ",(0,a.kt)("inlineCode",{parentName:"p"},"ProductsStore"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="cart.query.ts"',title:'"cart.query.ts"'},"import { combineLatest } from 'rxjs';\nimport { map } from 'rxjs';\n\n@Injectable({ providedIn: 'root' })\nexport class CartQuery extends QueryEntity<CartState> {\n  constructor(protected store: CartStore, private productsQuery: ProductsQuery) {\n    super(store);\n  }\n\n  selectItems$ = combineLatest([this.selectAll(), this.productsQuery.selectAll({ asObject: true })]).pipe(map(joinItems));\n}\n\nfunction joinItems([cartItems, products]: [CartItem[], Product[]]) {\n  return cartItems.map((item) => {\n    const product = products[item.productId];\n    return {\n      ...item,\n      ...product,\n      total: item.quantity * product.price,\n    };\n  });\n}\n")),(0,a.kt)("p",null,"We\u2019re using the ",(0,a.kt)("inlineCode",{parentName:"p"},"combineLatest()")," observable to get both the list of cart items and the products. Then we are mapping over them, merging a cart item with the corresponding product based on the ",(0,a.kt)("inlineCode",{parentName:"p"},"productId"),"."),(0,a.kt)("p",null,"You can find the complete tutorial ",(0,a.kt)("a",{parentName:"p",href:"https://engineering.datorama.com/building-a-shopping-cart-in-angular-using-akita-c41f6a6f7255"},"here"),"."))}m.isMDXComponent=!0}}]);