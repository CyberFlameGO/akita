"use strict";(self.webpackChunkakita_docs=self.webpackChunkakita_docs||[]).push([[348],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},g="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),g=l(n),d=o,h=g["".concat(p,".").concat(d)]||g[d]||u[d]||i;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[g]="string"==typeof e?e:o,r[1]=s;for(var l=2;l<i;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8737:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return p},default:function(){return d},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return g}});var a=n(3117),o=n(102),i=(n(7294),n(3905)),r=["components"],s={title:"Server Side Pagination"},p=void 0,l={unversionedId:"plugins/pagination",id:"plugins/pagination",title:"Server Side Pagination",description:"In many cases - for example, when working with very large data-sets - we don't want to work with the full collection in memory. Instead server-side paging is used, where the server sends just a single page at a time.",source:"@site/docs/plugins/pagination.mdx",sourceDirName:"plugins",slug:"/plugins/pagination",permalink:"/akita/docs/plugins/pagination",draft:!1,editUrl:"https://github.com/salesforce/akita/edit/master/docs/docs/plugins/pagination.mdx",tags:[],version:"current",frontMatter:{title:"Server Side Pagination"},sidebar:"docs",previous:{title:"Dirty Check",permalink:"/akita/docs/plugins/dirty-check"},next:{title:"Devtools",permalink:"/akita/docs/enhancers/devtools"}},c={},g=[{value:"Basic Pagination",id:"basic-pagination",level:2},{value:"Advanced Pagination",id:"advanced-pagination",level:2},{value:"Pagination Metadata",id:"pagination-metadata",level:2},{value:"API",id:"api",level:2},{value:"<code>pagesControls</code>",id:"pagescontrols",level:3},{value:"<code>range</code>",id:"range",level:3},{value:"<code>startWith</code>",id:"startwith",level:3},{value:"<code>cacheTimeout</code>",id:"cachetimeout",level:3}],u={toc:g};function d(e){var t=e.components,n=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In many cases - for example, when working with very large data-sets - we don't want to work with the full collection in memory. Instead server-side paging is used, where the server sends just a single page at a time."),(0,i.kt)("p",null,"Usually, we also want to cache pages that already have been fetched, in order to spare the need for an additional request."),(0,i.kt)("p",null,"The Paginator API provides two useful features:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Caching of pages which have already been fetched. "),(0,i.kt)("li",{parentName:"ol"},"A pagination functionally, which gives you all the things you need to manage pagination in the application.")),(0,i.kt)("h2",{id:"basic-pagination"},"Basic Pagination"),(0,i.kt)("p",null,"First, we need to create a new provider, let\u2019s say we need paginator for our contacts page:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="contacts-paginator.ts"',title:'"contacts-paginator.ts"'},"import { InjectionToken } from '@angular/core';\nimport { PaginatorPlugin } from '@datorama/akita';\nimport { ContactsQuery } from './contacts.query';\n\nexport const CONTACTS_PAGINATOR = \nnew InjectionToken('CONTACTS_PAGINATOR', {\n  providedIn: 'root',\n  factory: () => {\n    const contactsQuery = inject(ContactsQuery);\n    return new PaginatorPlugin(contactsQuery)\n            .withControls()\n            .withRange();\n  }\n});\n")),(0,i.kt)("p",null,"You should already be familiar with the above code. This is the regular process of creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"factory")," provider in Angular. We are creating a new ",(0,i.kt)("inlineCode",{parentName:"p"},"Paginator()"),", passing the ",(0,i.kt)("inlineCode",{parentName:"p"},"Query")," we want to use in our pagination."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Non-Angular applications can export the plugin without using DI. For example:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export const contactsPaginator= new PaginatorPlugin(contactsQuery)\n                      .withControls().withRange();\n"))),(0,i.kt)("p",null,"We call ",(0,i.kt)("inlineCode",{parentName:"p"},"withControls()"),", which will give us an array of pages so we ",(0,i.kt)("inlineCode",{parentName:"p"},"*ngFor")," on them and ",(0,i.kt)("inlineCode",{parentName:"p"},"withRange()")," which will give us the ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," values to display to the user. Now, we can use it in our component:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="contacts.component.ts"',title:'"contacts.component.ts"'},"import { PaginationResponse } from '@datorama/akita';\nimport { CONTACTS_PAGINATOR } from './contacts-paginator';\n\n@Component({})\nexport class ContactsPageComponent {\n  pagination$: Observable<PaginationResponse<ContactsState>>;\n  \n  constructor(@Inject(CONTACTS_PAGINATOR) \n              public paginatorRef: PaginatorPlugin<ContactsState>, \n              private contactsService: ContactsService) {}\n\n  ngOnInit() {\n     this.pagination$ = this.paginatorRef.pageChanges.pipe(\n       switchMap(( page ) => {\n         const reqFn = () => this.contactsService.getPage({\n           page,\n           perPage: 10\n         });\n\n         return this.paginatorRef.getPage(reqFn);\n       })\n     );\n  }\n\n  ngOnDestroy() {\n    this.paginatorRef.destroy();\n  }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Paginator")," provides you with a ",(0,i.kt)("inlineCode",{parentName:"p"},"pageChanges")," observable so you can listen to page changes and call the ",(0,i.kt)("inlineCode",{parentName:"p"},"getPage()")," method, passing the request function. ",(0,i.kt)("inlineCode",{parentName:"p"},"Paginator")," expects to get the following fields as part of the ",(0,i.kt)("inlineCode",{parentName:"p"},"response")," from the server:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="response.json"',title:'"response.json"'},'{\n  "perPage": 10,\n  "lastPage": "10",\n  "currentPage": "3",\n  "total": 150,\n  "data": [...]\n}\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"If you didn't provide the total property it will default to: ",(0,i.kt)("inlineCode",{parentName:"p"},"response.perPage * response.lastPage"))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Paginator")," also exposes all the data that you need to display as well as methods for controlling the page from the UI:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="contacts.component.html"',title:'"contacts.component.html"'},'<section>\n  <h1>Contacts</h1>\n  <loader *ngIf="paginatorRef.isLoading$ | async"><loader>\n\n  <section *ngIf="(pagination$ | async) as pagination">\n    <table>\n      <thead>\n        ..\n      </thead>\n      <tbody>\n        <tr *ngFor="let contact of pagination.data">\n          <td>{{contact.name}}</td>\n          ...\n        </tr>\n      </tbody>\n    </table>\n\n    <p>{{pagination.from}} - {{pagination.to}} of {{pagination.total}}</p>\n\n    <ul>\n      <li [class.disabled]="paginatorRef.isFirst" \n         (click)="paginatorRef.setFirstPage()">\n         First page\n      </li>\n      \n      <li [class.disabled]="paginatorRef.isFirst" (click)="paginatorRef.prevPage()">\n         Prev\n      </li>\n      \n      <li *ngFor="let page of pagination.pageControls"\n          (click)="paginatorRef.setPage(page)"\n          [class.active]="paginatorRef.isPageActive(page)">\n          {{page}}\n      </li>\n      \n      <li [class.disabled]="paginatorRef.isLast" (click)="paginatorRef.nextPage()">\n         Next\n      </li>\n      \n      <li [class.disabled]="paginatorRef.isLast" (click)="paginatorRef.setLastPage()">\n         Last\n      </li>\n    </ul>\n  </section>\n\n</section>\n')),(0,i.kt)("p",null,"That's all you need in order to get fully working pagination including caching."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"If you don't want Paginator to be a singleton you can skip the provider part and just create new instance directly in the component.")),(0,i.kt)("h2",{id:"advanced-pagination"},"Advanced Pagination"),(0,i.kt)("p",null,"There are times where we want to give our users the ability to filter the data, sort it, or change the number of entries per page. The vital step here is that when we change a filter, sort etc., we want to invalidate the cache, because it may alter the server response. Here is a fully working example of this type of functionality:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="contacts.component.ts"',title:'"contacts.component.ts"'},"import { PaginationResponse } from '@datorama/akita';\nimport { CONTACTS_PAGINATOR } from './contacts-paginator';\n\n@Component({})\nexport class ContactsPageComponent {\n  pagination$: Observable<PaginationResponse<ContactsState>>;\n  sortByControl: FormControl;\n  perPageControl: FormControl;\n\n  constructor(@Inject(CONTACTS_PAGINATOR) \n              public paginatorRef: PaginatorPlugin<ContactsState>, \n              private contactsService: ContactsService) {}\n\n  ngOnInit() {\n    this.sortByControl = new FormControl('price');\n    this.perPageControl = new FormControl(10);\n\n    const sort = this.sortByControl.valueChanges.pipe(startWith('price'));\n    const perPage = this.perPageControl.valueChanges.pipe(startWith(10));\n\n    this.pagination$ = combineLatest([\n      this.paginatorRef.pageChanges,\n      combineLatest([sort, perPage]).pipe(tap(() => this.paginatorRef.clearCache())),\n    ]).pipe(\n      switchMap(([page, [sortBy, perPage]]) => {\n        const req = () => this.contactsService.getPage({ page, sortBy, perPage });\n        return this.paginatorRef.getPage(req);\n      })\n    );\n  }\n\n  ngOnDestroy() {\n    this.paginatorRef.destroy();\n  }\n}\n")),(0,i.kt)("p",null,"When each filter emits a new value, we need to invalidate the cache, so that the ",(0,i.kt)("inlineCode",{parentName:"p"},"Paginator")," will know that it needs to re-fetch the data from the server."),(0,i.kt)("h2",{id:"pagination-metadata"},"Pagination Metadata"),(0,i.kt)("p",null,"Sometimes you want to save the current filters, so if the user navigates from the current route and comes back you want the filter values to persist. Paginator exposes a ",(0,i.kt)("inlineCode",{parentName:"p"},"metadata")," property where you can set these values. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="contacts.component.ts"',title:'"contacts.component.ts"'},"import { PaginationResponse } from '@datorama/akita';\nimport { CONTACTS_PAGINATOR } from './contacts-paginator';\n\n@Component({})\nexport class ContactsPageComponent {\n  pagination$: Observable<PaginationResponse<ContactsState>>;\n  \n  constructor(@Inject(CONTACTS_PAGINATOR) \n              public paginatorRef: PaginatorPlugin<ContactsState>, \n              private contactsService: ContactsService) {}\n\n  ngOnInit() {\n    const sortByInit = this.paginatorRef.metadata.get('sortBy') || 'name';\n    const perPageInit = this.paginatorRef.metadata.get('perPage') || 10;\n    \n    this.sortByControl = new FormControl(sortByInit);\n    this.perPageControl = new FormControl(perPageInit);\n    \n   const sort = this.sortByControl.valueChanges.pipe(startWith(sortByInit));\n    const perPage = this.perPageControl.valueChanges.pipe(startWith(perPageInit));\n\n    this.pagination$ = combineLatest([\n      this.paginatorRef.pageChanges,\n      combineLatest([sort, perPage]).pipe(tap(() => this.paginatorRef.clearCache())),\n    ]).pipe(\n      switchMap(([page, [sortBy, perPage]]) => {\n        const req = () => this.contactsService.getPage({ page, sortBy, perPage });\n        this.paginatorRef.metadata.set('sortBy', sortBy);\n        this.paginatorRef.metadata.set('perPage', perPage);\n\n        return this.paginatorRef.getPage(req);\n      })\n    );\n  }\n\n  ngOnDestroy() {\n    this.paginatorRef.destroy();\n  }\n}\n")),(0,i.kt)("h2",{id:"api"},"API"),(0,i.kt)("h3",{id:"pagescontrols"},(0,i.kt)("inlineCode",{parentName:"h3"},"pagesControls")),(0,i.kt)("p",null,"Whether to generate page controls"),(0,i.kt)("h3",{id:"range"},(0,i.kt)("inlineCode",{parentName:"h3"},"range")),(0,i.kt)("p",null,"Whether to generate range (from, to)"),(0,i.kt)("h3",{id:"startwith"},(0,i.kt)("inlineCode",{parentName:"h3"},"startWith")),(0,i.kt)("p",null,"Page to start with"),(0,i.kt)("h3",{id:"cachetimeout"},(0,i.kt)("inlineCode",{parentName:"h3"},"cacheTimeout")),(0,i.kt)("p",null,"Observable that'll invalidate the cache when emits. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"interval(10000)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"new PaginatorPlugin({\n  pagesControls: false,\n  range: false,\n  startWith: 1,\n  cacheTimeout: Observable<any>\n})\n")))}d.isMDXComponent=!0}}]);