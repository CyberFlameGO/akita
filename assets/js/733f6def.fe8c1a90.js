"use strict";(self.webpackChunkakita_docs=self.webpackChunkakita_docs||[]).push([[4557],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return y}});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),h=r,y=d["".concat(l,".").concat(h)]||d[h]||u[h]||a;return n?i.createElement(y,o(o({ref:t},p),{},{components:n})):i.createElement(y,o({ref:t},p))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<a;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5542:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d}});var i=n(3117),r=n(102),a=(n(7294),n(3905)),o=["components"],s={title:"Dirty Check"},l=void 0,c={unversionedId:"plugins/dirty-check",id:"plugins/dirty-check",title:"Dirty Check",description:"The DirtyCheckPlugin is useful for cases when you want an indication whether the state is dirty (data in the store has been modified). For example, you may want to display a save button only if the user changes something.",source:"@site/docs/plugins/dirty-check.mdx",sourceDirName:"plugins",slug:"/plugins/dirty-check",permalink:"/akita/docs/plugins/dirty-check",draft:!1,editUrl:"https://github.com/salesforce/akita/edit/master/docs/docs/plugins/dirty-check.mdx",tags:[],version:"current",frontMatter:{title:"Dirty Check"},sidebar:"docs",previous:{title:"State History",permalink:"/akita/docs/plugins/state-history"},next:{title:"Server Side Pagination",permalink:"/akita/docs/plugins/pagination"}},p={},d=[{value:"Options",id:"options",level:2},{value:"<code>comparator</code>",id:"comparator",level:3},{value:"<code>watchProperty</code>",id:"watchproperty",level:3},{value:"EntityDirtyCheckPlugin",id:"entitydirtycheckplugin",level:2},{value:"Options",id:"options-1",level:3},{value:"<code>entityIds</code>",id:"entityids",level:3}],u={toc:d};function h(e){var t=e.components,n=(0,r.Z)(e,o);return(0,a.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"DirtyCheckPlugin")," is useful for cases when you want an indication whether the state is dirty (data in the store has been modified). For example, you may want to display a save button only if the user changes something."),(0,a.kt)("p",null,"To activate the plugin you need to create a new instance of ",(0,a.kt)("inlineCode",{parentName:"p"},"DirtyCheckPlugin"),", providing it with the ",(0,a.kt)("inlineCode",{parentName:"p"},"Query"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="widgets.component.ts"',title:'"widgets.component.ts"'},"import { DirtyCheckPlugin } from '@datorama/akita';\n\nexport class WidgetsComponent {\n  widgets$ = this.widgetsQuery.selectAll();\n  private dirtyCheck: DirtyCheckPlugin;\n\n  constructor(private widgetsQuery: WidgetsQuery) {}\n\n  ngOnInit() {\n    this.dirtyCheck = new DirtyCheckPlugin(this.widgetsQuery).setHead();\n  }\n\n  reset() {\n    this.dirtyCheck.reset();\n  }\n\n  ngOnDestroy() {\n    this.dirtyCheck.destroy();\n  }\n}\n")),(0,a.kt)("p",null,"From the moment you call ",(0,a.kt)("inlineCode",{parentName:"p"},"setHead()"),", Akita's ",(0,a.kt)("inlineCode",{parentName:"p"},"DirtyCheckPlugin")," takes the current store snapshot and saves it as the head (the value that we compare against). With every change to the store the plugin will compare it to the head value and notify you whether the state is dirty."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="widgets.component.html"',title:'"widgets.component.html"'},'<button [disabled]="!(dirtyCheck.isDirty$| async)" (click)="save()">Save Changes</button>\n')),(0,a.kt)("p",null,"By calling ",(0,a.kt)("inlineCode",{parentName:"p"},"reset()")," you are telling the plugin to update the store with the ",(0,a.kt)("inlineCode",{parentName:"p"},"head")," value. The plugin also provides a special method called isPathDirty() that checks whether a given ",(0,a.kt)("inlineCode",{parentName:"p"},"path")," is ",(0,a.kt)("inlineCode",{parentName:"p"},"dirty"),". For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const dirtyCheck = new DirtyCheckPlugin(widgetsQuery).setHead();\ndirtyCheck.isPathDirty('check.this.path');\n")),(0,a.kt)("p",null,"If you have set the head, you can get the current head value with ",(0,a.kt)("inlineCode",{parentName:"p"},"getHead()"),"."),(0,a.kt)("h2",{id:"options"},"Options"),(0,a.kt)("h3",{id:"comparator"},(0,a.kt)("inlineCode",{parentName:"h3"},"comparator")),(0,a.kt)("p",null,"The default ",(0,a.kt)("inlineCode",{parentName:"p"},"comparator")," compares the object by using the native ",(0,a.kt)("inlineCode",{parentName:"p"},"JSON.stringify()")," method, but you can pass a custom ",(0,a.kt)("inlineCode",{parentName:"p"},"comparator"),", for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { isEqual } from 'lodash.isequal';\n\nconst options = { comparator: (a, b) => !isEqual(a, b) };\nconst dirtyCheck = new DirtyCheckPlugin(widgetsQuery, options);\n")),(0,a.kt)("h3",{id:"watchproperty"},(0,a.kt)("inlineCode",{parentName:"h3"},"watchProperty")),(0,a.kt)("p",null,"The dirty check plugin can watch specific properties in your store's state and not just the entire store, this can be achieved by passing the properties keys to ",(0,a.kt)("inlineCode",{parentName:"p"},"DirtyCheckPlugin"),", for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// Tracks the entire store\nnew DirtyCheckPlugin(widgetsQuery);\n\n// Tracks the store's state name property\nnew DirtyCheckPlugin(widgetsQuery, { watchProperty: 'name' });\n\n// Tracks a set of properties\nnew DirtyCheckPlugin(widgetsQuery, { watchProperty: ['name', 'color'] });\n\n// In case of an EntityStore we can also track all the entities\nnew DirtyCheckPlugin(widgetsQuery, { watchProperty: 'entities' });\n")),(0,a.kt)("p",null,"After the first time you call ",(0,a.kt)("inlineCode",{parentName:"p"},"setHead()"),", each subsequent call to this method will re-set the current store value as the ",(0,a.kt)("inlineCode",{parentName:"p"},"head")," and update the dirtiness to ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,a.kt)("h2",{id:"entitydirtycheckplugin"},"EntityDirtyCheckPlugin"),(0,a.kt)("p",null,"In addition to the general dirty check functionality, Akita also provides a powerful API to help keep track of one or many entities, instead of the entire store."),(0,a.kt)("p",null,"A good example is when you have a table or a list of entities that the users can modify, and you want to give them a way to revert it per entity. Here is how you can do it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="widgets.component.ts"',title:'"widgets.component.ts"'},"import { EntityDirtyCheckPlugin } from '@datorama/akita';\n\nexport class WidgetsComponent {\n  widgets$ = this.widgetsQuery.selectAll();\n  private collection: EntityDirtyCheckPlugin;\n\n  constructor(private widgetsQuery: WidgetsQuery) {}\n\n  ngOnInit() {\n    this.collection = new EntityDirtyCheckPlugin(this.widgetsQuery);\n    this.collection.setHead();\n  }\n\n  updateWidget(id: ID, name: string) {\n    this.widgetService.updateWidget(id, name);\n  }\n\n  reset(ids) {\n    this.collection.reset(ids);\n  }\n\n  ngOnDestroy() {\n    this.collection.destroy();\n  }\n}\n")),(0,a.kt)("p",null,"With this setup you can track the dirtiness per entity and revert it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="widgets.component.html"',title:'"widgets.component.html"'},'<tbody>\n  <tr *ngFor="let widget of widgets$ | async">\n    <td>\n      <input [value]="widget.name" #name />\n    </td>\n    <td>\n      <button (click)="updateWidget(widget.id, name.value)">Save</button>\n    </td>\n    <td>\n      <button (click)="revert(widget.id)" [disabled]="!(collection.isDirty(widget.id) | async)">Revert</button>\n    </td>\n  </tr>\n</tbody>\n')),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("inlineCode",{parentName:"p"},"EntityDirtyCheckPlugin")," doesn't track the entities count. It only tracks changes on the entities themselves. If you want to track the addition or removal of entities, you can do so by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"DirtyCheckPlugin")," and watch the ",(0,a.kt)("inlineCode",{parentName:"p"},"entities")," property.")),(0,a.kt)("p",null,"Sometimes it's useful to partially reset the entity value when clicking on revert. The ",(0,a.kt)("inlineCode",{parentName:"p"},"revert()")," method can accept a custom ",(0,a.kt)("inlineCode",{parentName:"p"},"update")," function which receives as parameters the current ",(0,a.kt)("inlineCode",{parentName:"p"},"head")," and the current entity ",(0,a.kt)("inlineCode",{parentName:"p"},"value"),", and returns the modified entity. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const updateFn = (head, current) => {\n  return {\n    ...head,\n    title: current.title,\n  };\n};\n\ncollection.reset(entityId, { updateFn });\n")),(0,a.kt)("p",null,"In the above example we are reverting the whole entity except for the ",(0,a.kt)("inlineCode",{parentName:"p"},"title")," (note that this will still mark the entity as dirty)."),(0,a.kt)("p",null,"Sometimes it's also useful to check whether at least one of the entities is dirty. For this you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"someDirty()")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"collection.someDirty().subscribe(console.log);\n")),(0,a.kt)("h3",{id:"options-1"},"Options"),(0,a.kt)("h3",{id:"entityids"},(0,a.kt)("inlineCode",{parentName:"h3"},"entityIds")),(0,a.kt)("p",null,"A single id or an array of entity ids (default: all)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const options = { entityIds: [1, 2] };\nstateHistory = new EntityDirtyCheckPlugin(widgetsQuery, options);\n")))}h.isMDXComponent=!0}}]);